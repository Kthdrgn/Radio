// Radio Player Application
let player = null;
let currentStreamUrl = '';
const history = [];
const MAX_HISTORY = 10;

// DOM Elements
const playBtn = document.getElementById('play-btn');
const pauseBtn = document.getElementById('pause-btn');
const stopBtn = document.getElementById('stop-btn');
const volumeSlider = document.getElementById('volume');
const volumeValue = document.getElementById('volume-value');
const streamUrlInput = document.getElementById('stream-url');
const streamPreset = document.getElementById('stream-preset');
const loadStreamBtn = document.getElementById('load-stream-btn');
const statusDiv = document.getElementById('status');
const songTitle = document.getElementById('song-title');
const stationName = document.getElementById('station-name');
const stationDescription = document.getElementById('station-description');
const bitrate = document.getElementById('bitrate');
const genre = document.getElementById('genre');
const historyList = document.getElementById('history-list');

// Initialize player with URL
function initPlayer(url) {
    console.log('Initializing player with URL:', url);
    
    // Clean up existing player
    if (player) {
        try {
            player.stop();
            player.detachAudioElement();
        } catch (e) {
            console.log('Error cleaning up player:', e);
        }
    }

    currentStreamUrl = url;
    updateStatus('Initializing stream...', 'info');

    try {
        // Create new player instance with detailed callbacks
        player = new IcecastMetadataPlayer(url, {
            onMetadata: (metadata) => {
                console.log('Metadata received:', metadata);
                handleMetadata(metadata);
            },
            onStreamStart: () => {
                console.log('Stream started');
                handleStreamStart();
            },
            onStreamEnd: () => {
                console.log('Stream ended');
                handleStreamEnd();
            },
            onError: (error) => {
                console.error('Player error:', error);
                handleError(error);
            },
            onLoad: () => {
                console.log('Player loaded successfully');
            },
            metadataTypes: ["icy", "ogg"]
        });

        // Set initial volume
        player.audioElement.volume = volumeSlider.value / 100;

        console.log('Player instance created successfully');
        updateStatus('Stream loaded. Click Play to start.', 'info');
        
    } catch (error) {
        console.error('Failed to create player:', error);
        handleError(error);
    }
}

// Handle metadata updates
function handleMetadata(metadata) {
    console.log('Metadata received:', metadata);

    // Update song title
    if (metadata.StreamTitle) {
        songTitle.textContent = metadata.StreamTitle;
        addToHistory(metadata.StreamTitle);
    }

    // Update station info
    if (metadata.icyName) {
        stationName.textContent = metadata.icyName;
    }

    if (metadata.icyDescription) {
        stationDescription.textContent = metadata.icyDescription;
    }

    // Update stream details
    if (metadata.icyBr) {
        bitrate.textContent = `${metadata.icyBr} kbps`;
    }

    if (metadata.icyGenre) {
        genre.textContent = metadata.icyGenre;
    }
}

// Handle stream start
function handleStreamStart() {
    console.log('Stream started');
    updateStatus('Playing...', 'playing');
    showPauseButton();
}

// Handle stream end
function handleStreamEnd() {
    console.log('Stream ended');
    updateStatus('Stream ended', 'info');
    showPlayButton();
}

// Handle errors
function handleError(error) {
    console.error('Player error:', error);
    let errorMessage = 'Error loading stream';
    
    if (error.message) {
        if (error.message.includes('CORS')) {
            errorMessage = 'CORS Error: Stream server needs CORS headers configured';
        } else if (error.message.includes('Failed to fetch')) {
            errorMessage = 'Unable to connect to stream. Check URL and CORS settings.';
        } else {
            errorMessage = `Error: ${error.message}`;
        }
    }
    
    updateStatus(errorMessage, 'error');
    showPlayButton();
}

// Add song to history
function addToHistory(title) {
    const timestamp = new Date().toLocaleTimeString();
    
    // Don't add duplicates consecutively
    if (history.length > 0 && history[0].title === title) {
        return;
    }

    history.unshift({ title, timestamp });
    
    // Keep only last MAX_HISTORY items
    if (history.length > MAX_HISTORY) {
        history.pop();
    }

    updateHistoryDisplay();
}

// Update history display
function updateHistoryDisplay() {
    historyList.innerHTML = '';
    
    history.forEach(item => {
        const li = document.createElement('li');
        li.innerHTML = `
            <span class="song">${item.title}</span>
            <span class="time">${item.timestamp}</span>
        `;
        historyList.appendChild(li);
    });
}

// Update status message
function updateStatus(message, type = 'info') {
    statusDiv.textContent = message;
    statusDiv.className = 'status';
    
    if (type === 'playing') {
        statusDiv.classList.add('playing');
    } else if (type === 'error') {
        statusDiv.classList.add('error');
    }
}

// Show/hide control buttons
function showPlayButton() {
    playBtn.style.display = 'flex';
    pauseBtn.style.display = 'none';
}

function showPauseButton() {
    playBtn.style.display = 'none';
    pauseBtn.style.display = 'flex';
}

// Event Listeners
playBtn.addEventListener('click', () => {
    console.log('Play button clicked');
    
    if (!player) {
        console.log('No player instance, creating one...');
        initPlayer(streamUrlInput.value);
    }
    
    try {
        console.log('Calling player.play()...');
        player.play().then(() => {
            console.log('Play promise resolved');
            updateStatus('Playing...', 'playing');
        }).catch(err => {
            console.error('Play promise rejected:', err);
            handleError(err);
        });
        updateStatus('Starting playback...', 'info');
    } catch (error) {
        console.error('Exception during play:', error);
        handleError(error);
    }
});

pauseBtn.addEventListener('click', () => {
    if (player) {
        player.stop();
        updateStatus('Paused', 'info');
        showPlayButton();
    }
});

stopBtn.addEventListener('click', () => {
    if (player) {
        player.stop();
        songTitle.textContent = 'Stopped';
        updateStatus('Stopped', 'info');
        showPlayButton();
    }
});

volumeSlider.addEventListener('input', (e) => {
    const volume = e.target.value;
    volumeValue.textContent = `${volume}%`;
    
    if (player && player.audioElement) {
        player.audioElement.volume = volume / 100;
    }
});

loadStreamBtn.addEventListener('click', () => {
    const url = streamUrlInput.value.trim();
    
    if (!url) {
        updateStatus('Please enter a stream URL', 'error');
        return;
    }

    // Reset metadata display
    songTitle.textContent = 'Loading...';
    stationName.textContent = 'Radio Station';
    stationDescription.textContent = '';
    bitrate.textContent = '';
    genre.textContent = '';
    
    initPlayer(url);
});

// Allow Enter key to load stream
streamUrlInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        loadStreamBtn.click();
    }
});

// Handle preset selection
streamPreset.addEventListener('change', (e) => {
    const selectedUrl = e.target.value;
    if (selectedUrl) {
        streamUrlInput.value = selectedUrl;
        console.log('Preset selected:', selectedUrl);
    }
});

// Initialize with default stream on load
window.addEventListener('DOMContentLoaded', () => {
    updateStatus('Ready to play. Enter a stream URL and click Load Stream.', 'info');
    
    // If there's a default URL, you can auto-load it
    const defaultUrl = streamUrlInput.value;
    if (defaultUrl) {
        // Optionally auto-load on startup
        // initPlayer(defaultUrl);
    }
});

// Handle page unload
window.addEventListener('beforeunload', () => {
    if (player) {
        player.stop();
    }
});
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radio Player</title>
    
    <!-- Load the icecast-metadata-player library from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/icecast-metadata-player@1.17.13/build/icecast-metadata-player-1.17.13.main.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: white;
        }
        
        .player-container {
            max-width: 500px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }
        
        /* Station selector button */
        .station-selector-btn {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            color: white;
            font-weight: 500;
        }
        
        .station-selector-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }
        
        /* Station display with info */
        .station-display {
            width: 100%;
            padding: 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .station-display:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }
        
        .station-display-icon {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            object-fit: cover;
            background: rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }
        
        .station-display-info {
            flex: 1;
            text-align: left;
        }
        
        .station-display-name {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 6px;
            color: white;
        }
        
        .station-display-genres {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .station-display-change {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            flex-shrink: 0;
        }
        
        /* Album art container */
        .artwork-container {
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .album-art {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .album-art-placeholder {
            font-size: 120px;
            opacity: 0.5;
        }
        
        /* Metadata section */
        .metadata-section {
            text-align: center;
            width: 100%;
            padding: 0 20px;
        }
        
        .now-playing-label {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 15px;
        }
        
        .song-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 8px;
            color: white;
        }
        
        .artist-name {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 6px;
        }
        
        .album-name {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .no-metadata {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
        }
        
        /* Controls */
        .controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
        }
        
        .btn {
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .btn-play {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-play:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 6px 30px rgba(102, 126, 234, 0.5);
        }
        
        .btn-stop {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-stop:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Quality selector */
        .quality-section {
            width: 100%;
            max-width: 400px;
        }
        
        .quality-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .quality-btn {
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .quality-btn:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        .quality-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: transparent;
        }
        
        .quality-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        /* Status */
        .status {
            font-size: 14px;
            text-align: center;
            padding: 10px 20px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
            margin-top: 10px;
        }
        
        .status.error {
            background: rgba(255, 59, 48, 0.2);
            color: #ff6b6b;
        }
        
        .status.playing {
            background: rgba(52, 199, 89, 0.2);
            color: #5dff8a;
        }
        
        .status.loading {
            background: rgba(255, 149, 0, 0.2);
            color: #ffb84d;
        }
        
        .status.stopped {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.6);
        }
        
        /* Station Overlay */
        .station-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 1000;
            padding: 20px;
        }
        
        .station-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .station-modal {
            background: #2d2d2d;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-title {
            font-size: 24px;
            font-weight: 700;
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 28px;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.2s;
        }
        
        .close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        .search-box {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 16px;
            margin-bottom: 20px;
            transition: all 0.2s;
        }
        
        .search-box:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .station-list {
            overflow-y: auto;
            flex: 1;
            margin-bottom: 20px;
        }
        
        .station-item {
            display: flex;
            align-items: center;
            padding: 15px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
            gap: 15px;
        }
        
        .station-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }
        
        .station-item.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .station-icon {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            object-fit: cover;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .station-info {
            flex: 1;
        }
        
        .station-name {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 4px;
        }
        
        .station-details {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .delete-btn {
            background: rgba(255, 59, 48, 0.2);
            border: 1px solid rgba(255, 59, 48, 0.4);
            color: #ff6b6b;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .delete-btn:hover {
            background: rgba(255, 59, 48, 0.3);
            transform: scale(1.05);
        }
        
        .modal-actions {
            display: flex;
            gap: 10px;
        }
        
        .modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-add {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-add:hover {
            transform: scale(1.02);
        }
        
        .btn-import {
            background: rgba(52, 199, 89, 0.2);
            color: #5dff8a;
            border: 2px solid rgba(52, 199, 89, 0.4);
        }
        
        .btn-import:hover {
            background: rgba(52, 199, 89, 0.3);
        }
        
        .btn-export {
            background: rgba(255, 149, 0, 0.2);
            color: #ffb84d;
            border: 2px solid rgba(255, 149, 0, 0.4);
        }
        
        .btn-export:hover {
            background: rgba(255, 149, 0, 0.3);
        }
        
        /* Add Station Form */
        .add-form {
            display: none;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }
        
        .add-form.active {
            display: flex;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .form-label {
            font-size: 14px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .form-input {
            padding: 10px 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .form-input:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .form-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }
        
        .form-actions {
            display: flex;
            gap: 10px;
        }
        
        .btn-save {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-save:hover {
            transform: scale(1.02);
        }
        
        .btn-cancel {
            flex: 1;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-cancel:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .hidden-file-input {
            display: none;
        }
        
        /* Settings Section */
        .settings-section {
            width: 100%;
            max-width: 400px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            margin-top: 10px;
        }
        
        .settings-option {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .settings-option:last-child {
            margin-bottom: 0;
        }
        
        .settings-option input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .settings-option label {
            font-size: 14px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.8);
        }
    </style>
</head>
<body>
    <div class="player-container">
        <button class="station-selector-btn" id="stationSelectorBtn">
            Select a Station
        </button>
        
        <div class="station-display" id="stationDisplay" style="display: none;">
            <img src="" alt="Station Icon" class="station-display-icon" id="stationDisplayIcon">
            <div class="station-display-info">
                <div class="station-display-name" id="stationDisplayName"></div>
                <div class="station-display-genres" id="stationDisplayGenres"></div>
            </div>
            <div class="station-display-change">CHANGE</div>
        </div>
        
        <div class="artwork-container" id="artworkContainer">
            <div class="album-art-placeholder">🎵</div>
        </div>
        
        <div class="metadata-section" id="metadata">
            <div class="now-playing-label">NOW PLAYING</div>
            <div class="no-metadata">Select a station to start streaming</div>
        </div>
        
        <div class="quality-section">
            <div class="quality-selector">
                <button class="quality-btn" id="qualityLow">Low Quality</button>
                <button class="quality-btn active" id="qualityMedium">Medium Quality</button>
                <button class="quality-btn" id="qualityHigh">High Quality</button>
            </div>
        </div>
        
        <div class="controls">
            <button class="btn btn-play" id="playBtn">Play</button>
            <button class="btn btn-stop" id="stopBtn" disabled>Stop</button>
        </div>
        
        <div class="status" id="status">Ready to play</div>
        
        <div class="settings-section">
            <div class="settings-option">
                <input type="checkbox" id="useCorsProxyStation">
                <label for="useCorsProxyStation">Use CORS Proxy (enable if stream won't play)</label>
            </div>
        </div>
    </div>
    
    <!-- Station Selection Overlay -->
    <div class="station-overlay" id="stationOverlay">
        <div class="station-modal">
            <div class="modal-header">
                <h2 class="modal-title">Radio Stations</h2>
                <button class="close-btn" id="closeModalBtn">&times;</button>
            </div>
            
            <input 
                type="text" 
                class="search-box" 
                id="stationSearch" 
                placeholder="Search stations..."
            >
            
            <!-- Add Station Form -->
            <div class="add-form" id="addForm">
                <div class="form-group">
                    <label class="form-label">Station Name *</label>
                    <input type="text" class="form-input" id="formName" placeholder="e.g., Cool FM" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Stream URL *</label>
                    <input type="text" class="form-input" id="formUrl" placeholder="https://example.com/stream" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Low Quality URL</label>
                    <input type="text" class="form-input" id="formUrlLow" placeholder="Optional">
                </div>
                <div class="form-group">
                    <label class="form-label">High Quality URL</label>
                    <input type="text" class="form-input" id="formUrlHigh" placeholder="Optional">
                </div>
                <div class="form-group">
                    <label class="form-label">Icon URL</label>
                    <input type="text" class="form-input" id="formIcon" placeholder="https://example.com/icon.png">
                </div>
                <div class="form-group">
                    <label class="form-label">Frequency</label>
                    <input type="text" class="form-input" id="formFrequency" placeholder="e.g., 95.5 FM">
                </div>
                <div class="form-group">
                    <label class="form-label">Genres (comma-separated)</label>
                    <input type="text" class="form-input" id="formGenres" placeholder="e.g., Rock, Pop">
                </div>
                <div class="form-actions">
                    <button class="btn-save" id="saveStationBtn">Save Station</button>
                    <button class="btn-cancel" id="cancelAddBtn">Cancel</button>
                </div>
            </div>
            
            <div class="station-list" id="stationList">
                <!-- Stations will be populated here -->
            </div>
            
            <div class="modal-actions">
                <button class="modal-btn btn-add" id="addStationBtn">Add Station</button>
                <button class="modal-btn btn-import" id="importBtn">Import JSON</button>
                <button class="modal-btn btn-export" id="exportBtn">Export JSON</button>
            </div>
            
            <input type="file" class="hidden-file-input" id="fileInput" accept=".json">
        </div>
    </div>
    
    <script>
        // Elements
        const stationSelectorBtn = document.getElementById('stationSelectorBtn');
        const stationDisplay = document.getElementById('stationDisplay');
        const stationDisplayIcon = document.getElementById('stationDisplayIcon');
        const stationDisplayName = document.getElementById('stationDisplayName');
        const stationDisplayGenres = document.getElementById('stationDisplayGenres');
        const stationOverlay = document.getElementById('stationOverlay');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const stationList = document.getElementById('stationList');
        const stationSearch = document.getElementById('stationSearch');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const qualityLow = document.getElementById('qualityLow');
        const qualityMedium = document.getElementById('qualityMedium');
        const qualityHigh = document.getElementById('qualityHigh');
        const artworkContainer = document.getElementById('artworkContainer');
        const metadataDiv = document.getElementById('metadata');
        const statusDiv = document.getElementById('status');
        
        // Add/Edit elements
        const addStationBtn = document.getElementById('addStationBtn');
        const addForm = document.getElementById('addForm');
        const saveStationBtn = document.getElementById('saveStationBtn');
        const cancelAddBtn = document.getElementById('cancelAddBtn');
        const importBtn = document.getElementById('importBtn');
        const exportBtn = document.getElementById('exportBtn');
        const fileInput = document.getElementById('fileInput');
        
        // State
        let stations = [];
        let filteredStations = [];
        let currentStation = null;
        let player = null;
        let selectedQuality = 'medium';
        
        // Load stations from JSON file
        async function loadStations() {
            try {
                const response = await fetch('stations.json');
                stations = await response.json();
                filteredStations = [...stations];
                renderStations();
            } catch (error) {
                console.error('Error loading stations:', error);
                updateStatus('Error loading stations', 'error');
                // Initialize with empty array if file not found
                stations = [];
                filteredStations = [];
            }
        }
        
        // Render stations list
        function renderStations() {
            stationList.innerHTML = '';
            
            if (filteredStations.length === 0) {
                stationList.innerHTML = '<div style="text-align: center; padding: 20px; color: rgba(255, 255, 255, 0.5);">No stations found</div>';
                return;
            }
            
            filteredStations.forEach((station, index) => {
                const stationItem = document.createElement('div');
                stationItem.className = 'station-item';
                if (currentStation && currentStation.name === station.name) {
                    stationItem.classList.add('selected');
                }
                
                const icon = station.icon_url 
                    ? `<img src="${station.icon_url}" class="station-icon" onerror="this.style.display='none'">`
                    : `<div class="station-icon"></div>`;
                
                const frequency = station.frequency ? ` - ${station.frequency}` : '';
                const genres = station.genres && station.genres.length > 0 
                    ? station.genres.join(', ') 
                    : '';
                
                stationItem.innerHTML = `
                    ${icon}
                    <div class="station-info">
                        <div class="station-name">${station.name}${frequency}</div>
                        <div class="station-details">${genres}</div>
                    </div>
                    <button class="delete-btn" onclick="deleteStation(${stations.indexOf(station)}); event.stopPropagation();">Delete</button>
                `;
                
                stationItem.addEventListener('click', () => {
                    selectStation(station);
                    stationOverlay.classList.remove('active');
                });
                
                stationList.appendChild(stationItem);
            });
        }
        
        // Select a station
        function selectStation(station) {
            currentStation = station;
            
            // Update simple selector button
            stationSelectorBtn.textContent = station.name;
            
            // Update detailed station display
            stationDisplayName.textContent = station.name + (station.frequency ? ` - ${station.frequency}` : '');
            
            const genres = station.genres && station.genres.length > 0 
                ? station.genres.join(', ') 
                : 'No genres listed';
            stationDisplayGenres.textContent = genres;
            
            if (station.icon_url) {
                stationDisplayIcon.src = station.icon_url;
                stationDisplayIcon.style.display = 'block';
                stationDisplayIcon.onerror = function() {
                    this.style.display = 'none';
                };
            } else {
                stationDisplayIcon.style.display = 'none';
            }
            
            // Show the detailed display, hide simple button
            stationSelectorBtn.style.display = 'none';
            stationDisplay.style.display = 'flex';
            
            updateQualityButtons();
            renderStations();
        }
        
        // Update quality buttons based on available streams
        function updateQualityButtons() {
            if (!currentStation) {
                qualityLow.disabled = true;
                qualityMedium.disabled = false;
                qualityHigh.disabled = true;
                return;
            }
            
            qualityLow.disabled = !currentStation.url_low;
            qualityMedium.disabled = false;
            qualityHigh.disabled = !currentStation.url_high;
        }
        
        // Quality button handlers
        qualityLow.addEventListener('click', () => {
            selectedQuality = 'low';
            updateQualityUI();
        });
        
        qualityMedium.addEventListener('click', () => {
            selectedQuality = 'medium';
            updateQualityUI();
        });
        
        qualityHigh.addEventListener('click', () => {
            selectedQuality = 'high';
            updateQualityUI();
        });
        
        function updateQualityUI() {
            qualityLow.classList.remove('active');
            qualityMedium.classList.remove('active');
            qualityHigh.classList.remove('active');
            
            if (selectedQuality === 'low') qualityLow.classList.add('active');
            else if (selectedQuality === 'medium') qualityMedium.classList.add('active');
            else if (selectedQuality === 'high') qualityHigh.classList.add('active');
        }
        
        // Station overlay handlers
        stationSelectorBtn.addEventListener('click', () => {
            stationOverlay.classList.add('active');
            stationSearch.value = '';
            filterStations('');
            stationSearch.focus();
        });
        
        stationDisplay.addEventListener('click', () => {
            stationOverlay.classList.add('active');
            stationSearch.value = '';
            filterStations('');
            stationSearch.focus();
        });
        
        closeModalBtn.addEventListener('click', () => {
            stationOverlay.classList.remove('active');
            addForm.classList.remove('active');
        });
        
        stationOverlay.addEventListener('click', (e) => {
            if (e.target === stationOverlay) {
                stationOverlay.classList.remove('active');
                addForm.classList.remove('active');
            }
        });
        
        // Search functionality
        stationSearch.addEventListener('input', (e) => {
            filterStations(e.target.value);
        });
        
        function filterStations(query) {
            const searchTerm = query.toLowerCase();
            filteredStations = stations.filter(station => {
                const name = station.name.toLowerCase();
                const genres = station.genres ? station.genres.join(' ').toLowerCase() : '';
                const frequency = station.frequency ? station.frequency.toLowerCase() : '';
                return name.includes(searchTerm) || 
                       genres.includes(searchTerm) || 
                       frequency.includes(searchTerm);
            });
            renderStations();
        }
        
        // Add station functionality
        addStationBtn.addEventListener('click', () => {
            addForm.classList.add('active');
            document.getElementById('formName').focus();
        });
        
        cancelAddBtn.addEventListener('click', () => {
            addForm.classList.remove('active');
            clearForm();
        });
        
        saveStationBtn.addEventListener('click', () => {
            const name = document.getElementById('formName').value.trim();
            const url = document.getElementById('formUrl').value.trim();
            
            if (!name || !url) {
                alert('Station name and URL are required!');
                return;
            }
            
            const genres = document.getElementById('formGenres').value
                .split(',')
                .map(g => g.trim())
                .filter(g => g.length > 0);
            
            const newStation = {
                name: name,
                url: url,
                url_low: document.getElementById('formUrlLow').value.trim() || null,
                url_high: document.getElementById('formUrlHigh').value.trim() || null,
                website_url: null,
                description: null,
                genres: genres,
                call_letters: null,
                frequency: document.getElementById('formFrequency').value.trim() || null,
                icon_url: document.getElementById('formIcon').value.trim() || null
            };
            
            stations.push(newStation);
            filteredStations = [...stations];
            renderStations();
            addForm.classList.remove('active');
            clearForm();
            
            updateStatus(`Added station: ${name}`, 'playing');
            setTimeout(() => updateStatus('Ready to play', ''), 3000);
        });
        
        function clearForm() {
            document.getElementById('formName').value = '';
            document.getElementById('formUrl').value = '';
            document.getElementById('formUrlLow').value = '';
            document.getElementById('formUrlHigh').value = '';
            document.getElementById('formIcon').value = '';
            document.getElementById('formFrequency').value = '';
            document.getElementById('formGenres').value = '';
        }
        
        // Delete station functionality
        function deleteStation(index) {
            if (confirm(`Delete station "${stations[index].name}"?`)) {
                const deletedName = stations[index].name;
                stations.splice(index, 1);
                
                // Update current station if it was deleted
                if (currentStation && currentStation.name === deletedName) {
                    currentStation = null;
                    stationSelectorBtn.textContent = 'Select a Station';
                    stationSelectorBtn.style.display = 'block';
                    stationDisplay.style.display = 'none';
                    if (player) {
                        player.stop();
                    }
                }
                
                filteredStations = [...stations];
                renderStations();
                
                updateStatus(`Deleted station: ${deletedName}`, 'error');
                setTimeout(() => updateStatus('Ready to play', ''), 3000);
            }
        }
        
        // Export stations to JSON
        exportBtn.addEventListener('click', () => {
            const dataStr = JSON.stringify(stations, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'stations.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            updateStatus('Stations exported to stations.json', 'playing');
            setTimeout(() => updateStatus('Ready to play', ''), 3000);
        });
        
        // Import stations from JSON
        importBtn.addEventListener('click', () => {
            fileInput.click();
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const importedStations = JSON.parse(event.target.result);
                    if (Array.isArray(importedStations)) {
                        stations = importedStations;
                        filteredStations = [...stations];
                        renderStations();
                        updateStatus(`Imported ${stations.length} stations`, 'playing');
                        setTimeout(() => updateStatus('Ready to play', ''), 3000);
                    } else {
                        throw new Error('Invalid JSON format');
                    }
                } catch (error) {
                    console.error('Error importing stations:', error);
                    alert('Error importing stations. Please check the JSON file format.');
                }
                fileInput.value = '';
            };
            reader.readAsText(file);
        });
        
        // Update status message
        function updateStatus(message, statusClass) {
            statusDiv.textContent = message;
            statusDiv.className = 'status';
            if (statusClass) {
                statusDiv.classList.add(statusClass);
            }
        }
        
        // Get artwork from iTunes API
        async function getArtwork(artist, title, streamUrl = null) {
            // If stream provides artwork URL, try that first
            if (streamUrl) {
                try {
                    const img = new Image();
                    img.src = streamUrl;
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = reject;
                        setTimeout(reject, 5000);
                    });
                    return streamUrl;
                } catch (error) {
                    console.log('Stream artwork failed, trying iTunes');
                }
            }
            
            // Fall back to iTunes search
            if (!artist || !title) return null;
            
            try {
                const query = encodeURIComponent(`${artist} ${title}`);
                const response = await fetch(`https://itunes.apple.com/search?term=${query}&media=music&limit=1`);
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    return data.results[0].artworkUrl100.replace('100x100', '600x600');
                }
            } catch (error) {
                console.error('iTunes API error:', error);
            }
            
            return null;
        }
        
        // Display metadata
        async function displayMetadata(metadata) {
            let title = 'Unknown Track';
            let artist = '';
            let album = '';
            let streamArtworkUrl = null;
            
            // Parse metadata
            if (metadata) {
                // Handle iHeartRadio extended metadata format
                if (metadata.StreamTitle) {
                    const streamTitle = metadata.StreamTitle;
                    
                    // Check for iHeartRadio format with text= and artist=
                    const textMatch = streamTitle.match(/text="([^"]+)"/);
                    const artistMatch = streamTitle.match(/artist="([^"]+)"/);
                    const artworkMatch = streamTitle.match(/amgArtworkURL="([^"]+)"/);
                    
                    if (textMatch || artistMatch) {
                        // iHeartRadio format
                        if (textMatch) title = textMatch[1].trim();
                        if (artistMatch) artist = artistMatch[1].trim();
                        if (artworkMatch) streamArtworkUrl = artworkMatch[1].trim();
                    } else {
                        // Standard format: Artist - Title
                        const parts = streamTitle.split(' - ');
                        if (parts.length >= 2) {
                            artist = parts[0].trim();
                            title = parts.slice(1).join(' - ').trim();
                        } else {
                            title = streamTitle.trim();
                        }
                    }
                }
                
                // Check for stream-provided artwork (if not already found)
                if (!streamArtworkUrl && metadata.StreamUrl) {
                    streamArtworkUrl = metadata.StreamUrl;
                }
                
                // Check for OGG metadata (overrides if present)
                if (metadata.ARTIST) artist = metadata.ARTIST;
                if (metadata.TITLE) title = metadata.TITLE;
                if (metadata.ALBUM) album = metadata.ALBUM;
            }
            
            // Check if we should search for artwork
            const shouldSearchArtwork = artist && title && 
                !artist.toLowerCase().includes('unknown') && 
                !title.toLowerCase().includes('unknown');
            
            // Show loading state in artwork container
            if (shouldSearchArtwork || streamArtworkUrl) {
                artworkContainer.innerHTML = `<div class="album-art-placeholder">🔍</div>`;
            }
            
            // Update metadata text
            metadataDiv.innerHTML = `
                <div class="now-playing-label">NOW PLAYING</div>
                ${title ? `<div class="song-title">${title}</div>` : ''}
                ${artist ? `<div class="artist-name">${artist}</div>` : ''}
                ${album ? `<div class="album-name">${album}</div>` : ''}
                ${!title && !artist ? `<div class="no-metadata">Streaming...</div>` : ''}
            `;
            
            // Get artwork (async) - only if we should search
            const artworkUrl = (shouldSearchArtwork || streamArtworkUrl) 
                ? await getArtwork(artist, title, streamArtworkUrl)
                : null;
            
            // Update artwork container
            if (artworkUrl) {
                artworkContainer.innerHTML = `
                    <img src="${artworkUrl}" alt="Album Art" class="album-art" 
                         onerror="this.innerHTML='<div class=\\'album-art-placeholder\\'>🎵</div>'">
                `;
            } else {
                artworkContainer.innerHTML = `<div class="album-art-placeholder">🎵</div>`;
            }
            
            // Update Media Session API
            updateMediaSession(title, artist, album, artworkUrl);
        }
        
        // Media Session API - Update notification metadata
        function updateMediaSession(title, artist, album, artworkUrl) {
            if ('mediaSession' in navigator) {
                // Determine which artwork to use: track artwork, station favicon, or default
                let finalArtwork;
                
                if (artworkUrl) {
                    // Use track artwork if available
                    finalArtwork = [
                        { src: artworkUrl, sizes: '96x96', type: 'image/jpeg' },
                        { src: artworkUrl, sizes: '128x128', type: 'image/jpeg' },
                        { src: artworkUrl, sizes: '192x192', type: 'image/jpeg' },
                        { src: artworkUrl, sizes: '256x256', type: 'image/jpeg' },
                        { src: artworkUrl, sizes: '384x384', type: 'image/jpeg' },
                        { src: artworkUrl, sizes: '512x512', type: 'image/jpeg' }
                    ];
                } else if (currentStation && currentStation.favicon) {
                    // Use station favicon if no track artwork
                    finalArtwork = [
                        { src: currentStation.favicon, sizes: '96x96', type: 'image/png' },
                        { src: currentStation.favicon, sizes: '128x128', type: 'image/png' },
                        { src: currentStation.favicon, sizes: '192x192', type: 'image/png' },
                        { src: currentStation.favicon, sizes: '256x256', type: 'image/png' },
                        { src: currentStation.favicon, sizes: '384x384', type: 'image/png' },
                        { src: currentStation.favicon, sizes: '512x512', type: 'image/png' }
                    ];
                } else {
                    // Use default icon as last resort
                    finalArtwork = [
                        { src: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgZmlsbD0iIzY2N2VlYSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LXNpemU9IjI1MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iIGZpbGw9IiNmZmYiPjwvdGV4dD48L3N2Zz4=', 
                          sizes: '512x512', 
                          type: 'image/svg+xml' 
                        }
                    ];
                }
                
                // Set metadata
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: title || 'Unknown Track',
                    artist: artist || (currentStation ? currentStation.name : 'Radio Stream'),
                    album: album || (currentStation ? currentStation.name : 'Live Radio'),
                    artwork: finalArtwork
                });
                
                console.log('Media Session updated:', {
                    title: title || 'Unknown Track',
                    artist: artist || (currentStation ? currentStation.name : 'Radio Stream'),
                    album: album || (currentStation ? currentStation.name : 'Live Radio'),
                    artworkSource: artworkUrl ? 'track' : (currentStation && currentStation.favicon ? 'station' : 'default')
                });
            }
        }
        
        // Setup Media Session action handlers
        function setupMediaSessionHandlers() {
            if ('mediaSession' in navigator) {
                // Play action
                navigator.mediaSession.setActionHandler('play', () => {
                    console.log('Media Session: Play action');
                    if (player) {
                        player.play().catch(err => console.error('Play error:', err));
                    } else {
                        playBtn.click();
                    }
                });
                
                // Pause action (for radio, we'll stop instead)
                navigator.mediaSession.setActionHandler('pause', () => {
                    console.log('Media Session: Pause action');
                    if (player) {
                        player.stop();
                    }
                });
                
                // Stop action
                navigator.mediaSession.setActionHandler('stop', () => {
                    console.log('Media Session: Stop action');
                    if (player) {
                        player.stop();
                    }
                });
                
                // Seek forward (skip to next station if available)
                navigator.mediaSession.setActionHandler('nexttrack', () => {
                    console.log('Media Session: Next track action');
                    // Find next station in the list
                    if (stations.length > 0 && currentStation) {
                        const currentIndex = stations.findIndex(s => s.stationuuid === currentStation.stationuuid);
                        const nextIndex = (currentIndex + 1) % stations.length;
                        selectStation(stations[nextIndex]);
                        setTimeout(() => playBtn.click(), 500);
                    }
                });
                
                // Seek backward (skip to previous station if available)
                navigator.mediaSession.setActionHandler('previoustrack', () => {
                    console.log('Media Session: Previous track action');
                    // Find previous station in the list
                    if (stations.length > 0 && currentStation) {
                        const currentIndex = stations.findIndex(s => s.stationuuid === currentStation.stationuuid);
                        const prevIndex = currentIndex > 0 ? currentIndex - 1 : stations.length - 1;
                        selectStation(stations[prevIndex]);
                        setTimeout(() => playBtn.click(), 500);
                    }
                });
                
                console.log('Media Session handlers setup complete');
            } else {
                console.log('Media Session API not supported in this browser');
            }
        }
        
        // Play button handler
        playBtn.addEventListener('click', async () => {
            const rawUrl = currentStation 
                ? (selectedQuality === 'low' && currentStation.url_low ? currentStation.url_low : 
                   selectedQuality === 'high' && currentStation.url_high ? currentStation.url_high : currentStation.url)
                : null;
            
            if (!rawUrl) {
                updateStatus('Please select a station', 'error');
                return;
            }
            
            // Stop existing player if running
            if (player) {
                player.stop();
            }
            
            // Update UI
            playBtn.disabled = true;
            stopBtn.disabled = false;
            updateStatus('Connecting...', 'loading');
            artworkContainer.innerHTML = `<div class="album-art-placeholder">🔄</div>`;
            metadataDiv.innerHTML = `
                <div class="now-playing-label">NOW PLAYING</div>
                <div class="no-metadata">Loading stream...</div>
            `;
            
            // Retry strategy: try different configurations
            const useCorsProxy = document.getElementById('useCorsProxyStation').checked;
            
            let attempts = [
                { url: rawUrl, cors: false, metadata: ['icy', 'ogg'] },
                { url: rawUrl, cors: false, metadata: ['ogg'] },
                { url: rawUrl, cors: false, metadata: [] },
                { url: rawUrl, cors: true, metadata: ['ogg'] },
                { url: rawUrl, cors: true, metadata: [] }
            ];
            
            // If user explicitly enabled CORS proxy, prioritize those attempts
            if (useCorsProxy) {
                attempts = [
                    { url: rawUrl, cors: true, metadata: ['icy', 'ogg'] },
                    { url: rawUrl, cors: true, metadata: ['ogg'] },
                    { url: rawUrl, cors: true, metadata: [] },
                    { url: rawUrl, cors: false, metadata: ['ogg'] },
                    { url: rawUrl, cors: false, metadata: [] }
                ];
            }
            
            let lastError = null;
            
            for (let i = 0; i < attempts.length; i++) {
                const attempt = attempts[i];
                const streamUrl = attempt.cors 
                    ? `https://corsproxy.io/?${encodeURIComponent(attempt.url)}`
                    : attempt.url;
                
                try {
                    if (i > 0) {
                        const metadataDesc = attempt.metadata.includes('icy') ? 'full metadata' :
                                           attempt.metadata.includes('ogg') ? 'OGG metadata' : 'no metadata';
                        const statusMsg = attempt.cors 
                            ? `Retrying with CORS proxy (${metadataDesc})...`
                            : `Retrying (${metadataDesc})...`;
                        updateStatus(statusMsg, 'loading');
                        console.log(`Attempt ${i + 1}/${attempts.length}: ${statusMsg}`);
                    }
                    
                    player = new IcecastMetadataPlayer(streamUrl, {
                        metadataTypes: attempt.metadata,
                        enableLogging: false,
                        
                        onMetadata: (metadata) => {
                            displayMetadata(metadata);
                        },
                        
                        onPlay: () => {
                            const statusMsg = attempt.metadata.length === 0 
                                ? 'Playing (no metadata available)'
                                : 'Playing';
                            updateStatus(statusMsg, 'playing');
                        },
                        
                        onStop: () => {
                            updateStatus('Stopped', 'stopped');
                            playBtn.disabled = false;
                            stopBtn.disabled = true;
                            artworkContainer.innerHTML = `<div class="album-art-placeholder">🎵</div>`;
                            metadataDiv.innerHTML = `
                                <div class="now-playing-label">NOW PLAYING</div>
                                <div class="no-metadata">Select a station to start streaming</div>
                            `;
                        },
                        
                        onError: (error) => {
                            console.error(`Player error on attempt ${i + 1}:`, error);
                        },
                        
                        bufferLength: 3,
                        retryTimeout: 5,
                        retryDelayRate: 0.5,
                        retryDelayMin: 1,
                        retryDelayMax: 10
                    });
                    
                    await player.play();
                    // If we get here, playback started successfully
                    return;
                    
                } catch (error) {
                    console.error(`Attempt ${i + 1}/${attempts.length} failed:`, error.message);
                    lastError = error;
                    
                    if (player) {
                        try {
                            player.stop();
                        } catch (e) {
                            // Ignore stop errors
                        }
                    }
                    
                    // If this isn't the last attempt, continue to next
                    if (i < attempts.length - 1) {
                        continue;
                    }
                }
            }
            
            // All attempts failed
            console.error('All connection attempts failed');
            updateStatus('Error: Unable to connect to stream. Try enabling/disabling CORS proxy.', 'error');
            playBtn.disabled = false;
            stopBtn.disabled = true;
        });
        
        // Stop button handler
        stopBtn.addEventListener('click', () => {
            if (player) {
                player.stop();
            }
        });
        
        // Allow Enter key to search in station overlay
        stationSearch.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && filteredStations.length === 1) {
                selectStation(filteredStations[0]);
                stationOverlay.classList.remove('active');
            }
        });
        
        // Initialize: Load stations
        loadStations();
        
        // Initialize Media Session API handlers
        setupMediaSessionHandlers();
    </script>
</body>
</html>

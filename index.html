<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radio Stream Player with Station Database</title>
    
    <!-- Load the icecast-metadata-player library from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/icecast-metadata-player@1.17.13/build/icecast-metadata-player-1.17.13.main.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .player-container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
        }
        
        .player-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .player-header h1 {
            color: #333;
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .station-count {
            color: #667eea;
            font-size: 14px;
            font-weight: 500;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group label {
            display: block;
            color: #666;
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        /* Station Browser Button Styles */
        .station-browser-btn {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #333;
        }
        
        .station-browser-btn:hover {
            border-color: #667eea;
            background: #f0f7ff;
        }
        
        .station-browser-btn .placeholder {
            color: #999;
        }
        
        .station-browser-btn .arrow {
            font-size: 18px;
            color: #667eea;
        }
        
        /* Modal Overlay Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            animation: fadeIn 0.2s ease-in;
        }
        
        .modal-overlay.active {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-content {
            background: white;
            border-radius: 20px;
            width: 100%;
            max-width: 800px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal-header {
            padding: 25px 30px;
            border-bottom: 2px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h2 {
            color: #333;
            font-size: 24px;
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #999;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }
        
        .close-btn:hover {
            background: #f0f0f0;
            color: #333;
        }
        
        .modal-controls {
            padding: 20px 30px;
            background: #f8f9fa;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .search-box {
            flex: 1;
            min-width: 200px;
            position: relative;
        }
        
        .search-box input {
            width: 100%;
            padding: 10px 35px 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        .search-box input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .search-icon {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #999;
            pointer-events: none;
        }
        
        .sort-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .sort-label {
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }
        
        .sort-btn {
            padding: 8px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .sort-btn:hover {
            border-color: #667eea;
            background: #f0f7ff;
        }
        
        .sort-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }
        
        .station-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px 30px 30px;
        }
        
        .station-item {
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .station-item:hover {
            border-color: #667eea;
            background: #f0f7ff;
            transform: translateX(5px);
        }
        
        .station-item.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            color: white;
        }
        
        .station-info {
            flex: 1;
        }
        
        .station-name {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 4px;
        }
        
        .station-meta {
            font-size: 13px;
            opacity: 0.8;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .station-genre {
            font-weight: 500;
        }
        
        .station-bitrate {
            display: flex;
            gap: 8px;
        }
        
        .bitrate-badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .station-item:not(.selected) .bitrate-badge {
            background: #f0f0f0;
            color: #666;
        }
        
        .no-results {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }
        
        .no-results-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .quality-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .quality-btn {
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            text-align: center;
        }
        
        .quality-btn:hover:not(:disabled) {
            border-color: #667eea;
            background: #f0f7ff;
        }
        
        .quality-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }
        
        .quality-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .api-info {
            background: #f0f7ff;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            color: #555;
            margin-top: 5px;
        }
        
        .api-info a {
            color: #667eea;
            text-decoration: none;
        }
        
        .api-info a:hover {
            text-decoration: underline;
        }
        
        .metadata-display {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
            min-height: 120px;
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .album-art-container {
            flex-shrink: 0;
            position: relative;
        }
        
        .album-art {
            width: 150px;
            height: 150px;
            border-radius: 8px;
            object-fit: cover;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .album-art-placeholder {
            width: 150px;
            height: 150px;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
        }
        
        .loading-spinner {
            width: 150px;
            height: 150px;
            border-radius: 8px;
            background: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #999;
        }
        
        .metadata-text {
            flex: 1;
            text-align: left;
        }
        
        .metadata-text.centered {
            text-align: center;
        }
        
        .now-playing-label {
            color: #999;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }
        
        .song-title {
            color: #333;
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 8px;
            word-wrap: break-word;
        }
        
        .artist-name {
            color: #666;
            font-size: 18px;
            word-wrap: break-word;
        }
        
        .album-name {
            color: #999;
            font-size: 14px;
            margin-top: 4px;
            font-style: italic;
        }
        
        .no-metadata {
            color: #999;
            font-style: italic;
            padding: 20px 0;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
        }
        
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
        }
        
        .btn-play {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-play:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-stop {
            background: #f44336;
            color: white;
        }
        
        .btn-stop:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(244, 67, 54, 0.4);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .status {
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .status.playing {
            background: #e8f5e9;
            color: #2e7d32;
        }
        
        .status.stopped {
            background: #ffebee;
            color: #c62828;
        }
        
        .status.loading {
            background: #fff3e0;
            color: #ef6c00;
        }
        
        .status.error {
            background: #ffebee;
            color: #c62828;
        }
        
        .mode-switch {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 5px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            color: #666;
        }
        
        .mode-btn.active {
            background: white;
            color: #667eea;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .mode-section {
            display: none;
        }
        
        .mode-section.active {
            display: block;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
            cursor: pointer;
        }
        
        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            font-size: 13px;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .modal-content {
                max-height: 95vh;
            }
            
            .modal-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .search-box {
                width: 100%;
            }
            
            .sort-controls {
                width: 100%;
                justify-content: space-between;
            }
            
            .metadata-display {
                flex-direction: column;
                text-align: center;
            }
            
            .metadata-text {
                text-align: center !important;
            }
        }
    </style>
</head>
<body>
    <div class="player-container">
        <div class="player-header">
            <h1>üéµ Radio Stream Player</h1>
            <div class="station-count" id="stationCount">Loading stations...</div>
        </div>
        
        <!-- Mode Switch -->
        <div class="mode-switch">
            <button class="mode-btn active" id="stationModeBtn">Station Database</button>
            <button class="mode-btn" id="customModeBtn">Custom URL</button>
        </div>
        
        <!-- Station Mode Section -->
        <div class="mode-section active" id="stationMode">
            <div class="input-group">
                <label>Select Station</label>
                <button class="station-browser-btn" id="stationBrowserBtn">
                    <span class="placeholder" id="selectedStationText">Click to browse stations</span>
                    <span class="arrow">‚ñº</span>
                </button>
            </div>
            
            <!-- Quality Selection (for stations) -->
            <div class="input-group">
                <label>Stream Quality</label>
                <div class="quality-selector" id="qualitySelectorStation">
                    <button class="quality-btn active" data-quality="medium">Medium</button>
                    <button class="quality-btn" data-quality="low">Low</button>
                    <button class="quality-btn" data-quality="high">High</button>
                </div>
            </div>
            
            <!-- CORS Proxy Option -->
            <div class="checkbox-group">
                <input type="checkbox" id="useCorsProxyStation">
                <label for="useCorsProxyStation">Use CORS Proxy (if station has CORS issues)</label>
            </div>
        </div>
        
        <!-- Custom URL Mode Section -->
        <div class="mode-section" id="customMode">
            <div class="input-group">
                <label for="streamUrl">Stream URL</label>
                <input type="text" id="streamUrl" placeholder="Enter Icecast/Shoutcast stream URL">
            </div>
            
            <!-- CORS Proxy Option -->
            <div class="checkbox-group">
                <input type="checkbox" id="useCorsProxy">
                <label for="useCorsProxy">Use CORS Proxy (if stream has CORS issues)</label>
            </div>
        </div>
        
        <!-- Artwork API Settings -->
        <div class="input-group">
            <label for="artworkApi">Album Artwork Source</label>
            <select id="artworkApi">
                <option value="itunes">iTunes (No API Key Required)</option>
                <option value="lastfm">Last.fm (Requires API Key)</option>
                <option value="none">No Artwork</option>
            </select>
        </div>
        
        <div class="input-group" id="apiKeyGroup" style="display: none;">
            <label for="apiKey">Last.fm API Key</label>
            <input type="text" id="apiKey" placeholder="Enter your Last.fm API key">
            <div class="api-info">
                Get your free API key at <a href="https://www.last.fm/api/account/create" target="_blank">Last.fm API</a>
            </div>
        </div>
        
        <!-- Metadata Display -->
        <div class="metadata-display" id="metadata">
            <div class="metadata-text centered">
                <div class="now-playing-label">NOW PLAYING</div>
                <div class="no-metadata">Select a station to start streaming</div>
            </div>
        </div>
        
        <!-- Controls -->
        <div class="controls">
            <button class="btn btn-play" id="playBtn">‚ñ∂ Play</button>
            <button class="btn btn-stop" id="stopBtn" disabled>‚¨õ Stop</button>
        </div>
        
        <div class="status" id="status"></div>
    </div>

    <!-- Station Browser Modal -->
    <div class="modal-overlay" id="stationModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Browse Stations</h2>
                <button class="close-btn" id="closeModalBtn">&times;</button>
            </div>
            
            <div class="modal-controls">
                <div class="search-box">
                    <input type="text" id="stationSearch" placeholder="Search stations...">
                    <span class="search-icon">üîç</span>
                </div>
                
                <div class="sort-controls">
                    <span class="sort-label">Sort:</span>
                    <button class="sort-btn active" data-sort="name">A-Z</button>
                    <button class="sort-btn" data-sort="genre">Genre</button>
                    <button class="sort-btn" data-sort="bitrate">Bitrate</button>
                </div>
            </div>
            
            <div class="station-list" id="stationList">
                <!-- Stations will be populated here -->
            </div>
        </div>
    </div>
    
    <script>
        // Get DOM elements
        const stationModeBtn = document.getElementById('stationModeBtn');
        const customModeBtn = document.getElementById('customModeBtn');
        const stationModeSection = document.getElementById('stationMode');
        const customModeSection = document.getElementById('customMode');
        const stationBrowserBtn = document.getElementById('stationBrowserBtn');
        const selectedStationText = document.getElementById('selectedStationText');
        const stationModal = document.getElementById('stationModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const stationList = document.getElementById('stationList');
        const stationSearch = document.getElementById('stationSearch');
        const sortButtons = document.querySelectorAll('.sort-btn');
        const streamUrlInput = document.getElementById('streamUrl');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const metadataDiv = document.getElementById('metadata');
        const statusDiv = document.getElementById('status');
        const artworkApiSelect = document.getElementById('artworkApi');
        const apiKeyGroup = document.getElementById('apiKeyGroup');
        const apiKeyInput = document.getElementById('apiKey');
        const qualitySelectorStation = document.getElementById('qualitySelectorStation');
        const stationCountDiv = document.getElementById('stationCount');
        
        // State variables
        let player = null;
        let stations = [];
        let filteredStations = [];
        let currentStation = null;
        let selectedQuality = 'medium';
        let isStationMode = true;
        let currentSort = 'name';
        
        // Mode switching
        stationModeBtn.addEventListener('click', () => {
            isStationMode = true;
            stationModeBtn.classList.add('active');
            customModeBtn.classList.remove('active');
            stationModeSection.classList.add('active');
            customModeSection.classList.remove('active');
        });
        
        customModeBtn.addEventListener('click', () => {
            isStationMode = false;
            customModeBtn.classList.add('active');
            stationModeBtn.classList.remove('active');
            customModeSection.classList.add('active');
            stationModeSection.classList.remove('active');
        });
        
        // Modal controls
        stationBrowserBtn.addEventListener('click', () => {
            stationModal.classList.add('active');
            renderStations();
        });
        
        closeModalBtn.addEventListener('click', () => {
            stationModal.classList.remove('active');
        });
        
        stationModal.addEventListener('click', (e) => {
            if (e.target === stationModal) {
                stationModal.classList.remove('active');
            }
        });
        
        // Search functionality
        stationSearch.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            filteredStations = stations.filter(station => 
                station.name.toLowerCase().includes(searchTerm) ||
                station.genre.toLowerCase().includes(searchTerm) ||
                station.country.toLowerCase().includes(searchTerm)
            );
            renderStations();
        });
        
        // Sort functionality
        sortButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                sortButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentSort = btn.dataset.sort;
                sortStations();
                renderStations();
            });
        });
        
        // Quality selection for stations
        qualitySelectorStation.addEventListener('click', (e) => {
            if (e.target.classList.contains('quality-btn') && !e.target.disabled) {
                qualitySelectorStation.querySelectorAll('.quality-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                e.target.classList.add('active');
                selectedQuality = e.target.dataset.quality;
                updateQualityAvailability();
            }
        });
        
        // Show/hide API key input based on selection
        artworkApiSelect.addEventListener('change', () => {
            apiKeyGroup.style.display = artworkApiSelect.value === 'lastfm' ? 'block' : 'none';
        });
        
        // Load stations from API
        async function loadStations() {
            try {
                const response = await fetch('https://de1.api.radio-browser.info/json/stations/search?limit=500&order=votes&reverse=true&hidebroken=true');
                stations = await response.json();
                filteredStations = [...stations];
                
                stationCountDiv.textContent = `${stations.length} stations available`;
                sortStations();
                
            } catch (error) {
                console.error('Error loading stations:', error);
                stationCountDiv.textContent = 'Error loading stations';
            }
        }
        
        // Sort stations
        function sortStations() {
            filteredStations.sort((a, b) => {
                switch (currentSort) {
                    case 'name':
                        return a.name.localeCompare(b.name);
                    case 'genre':
                        return a.genre.localeCompare(b.genre);
                    case 'bitrate':
                        return (b.bitrate || 0) - (a.bitrate || 0);
                    default:
                        return 0;
                }
            });
        }
        
        // Render stations in modal
        function renderStations() {
            if (filteredStations.length === 0) {
                stationList.innerHTML = `
                    <div class="no-results">
                        <div class="no-results-icon">üîç</div>
                        <div>No stations found</div>
                    </div>
                `;
                return;
            }
            
            stationList.innerHTML = filteredStations.map(station => {
                const isSelected = currentStation && currentStation.stationuuid === station.stationuuid;
                const bitrates = [];
                if (station.bitrate) bitrates.push(`${station.bitrate}k`);
                
                return `
                    <div class="station-item ${isSelected ? 'selected' : ''}" data-uuid="${station.stationuuid}">
                        <div class="station-info">
                            <div class="station-name">${station.name}</div>
                            <div class="station-meta">
                                <span class="station-genre">üéµ ${station.genre || 'Unknown'}</span>
                                <span>üåç ${station.country || 'Unknown'}</span>
                                ${bitrates.length > 0 ? `
                                    <span class="station-bitrate">
                                        ${bitrates.map(br => `<span class="bitrate-badge">${br}</span>`).join('')}
                                    </span>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add click handlers
            stationList.querySelectorAll('.station-item').forEach(item => {
                item.addEventListener('click', () => {
                    const uuid = item.dataset.uuid;
                    selectStation(uuid);
                });
            });
        }
        
        // Select a station
        function selectStation(uuid) {
            currentStation = stations.find(s => s.stationuuid === uuid);
            if (currentStation) {
                selectedStationText.textContent = currentStation.name;
                selectedStationText.classList.remove('placeholder');
                updateQualityAvailability();
                stationModal.classList.remove('active');
                renderStations(); // Re-render to show selection
            }
        }
        
        // Update quality button availability based on selected station
        function updateQualityAvailability() {
            if (!currentStation) return;
            
            const buttons = qualitySelectorStation.querySelectorAll('.quality-btn');
            buttons.forEach(btn => {
                const quality = btn.dataset.quality;
                let hasQuality = false;
                
                if (quality === 'medium' && currentStation.url) {
                    hasQuality = true;
                } else if (quality === 'low' && currentStation.url_resolved) {
                    hasQuality = true;
                } else if (quality === 'high' && currentStation.hls) {
                    hasQuality = true;
                }
                
                btn.disabled = !hasQuality;
            });
            
            // If current quality not available, switch to medium
            const currentBtn = qualitySelectorStation.querySelector(`[data-quality="${selectedQuality}"]`);
            if (currentBtn && currentBtn.disabled) {
                selectedQuality = 'medium';
                qualitySelectorStation.querySelectorAll('.quality-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                qualitySelectorStation.querySelector('[data-quality="medium"]').classList.add('active');
            }
        }
        
        // Update status message
        function updateStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
        }
        
        // Get artwork from APIs
        async function getArtwork(artist, title, streamUrl = null) {
            const apiType = artworkApiSelect.value;
            
            if (apiType === 'none') return null;
            
            // Try stream-provided artwork first
            if (streamUrl) {
                return streamUrl;
            }
            
            if (!artist || !title) return null;
            
            try {
                if (apiType === 'itunes') {
                    const searchTerm = `${artist} ${title}`;
                    const response = await fetch(
                        `https://itunes.apple.com/search?term=${encodeURIComponent(searchTerm)}&media=music&limit=1`
                    );
                    const data = await response.json();
                    
                    if (data.results && data.results.length > 0) {
                        // Get high quality artwork (600x600)
                        return data.results[0].artworkUrl100.replace('100x100', '600x600');
                    }
                } else if (apiType === 'lastfm') {
                    const apiKey = apiKeyInput.value.trim();
                    if (!apiKey) return null;
                    
                    const response = await fetch(
                        `https://ws.audioscrobbler.com/2.0/?method=track.getInfo&api_key=${apiKey}&artist=${encodeURIComponent(artist)}&track=${encodeURIComponent(title)}&format=json`
                    );
                    const data = await response.json();
                    
                    if (data.track && data.track.album && data.track.album.image) {
                        const images = data.track.album.image;
                        // Get largest image
                        const largeImage = images.find(img => img.size === 'extralarge' || img.size === 'large');
                        if (largeImage && largeImage['#text']) {
                            return largeImage['#text'];
                        }
                    }
                }
            } catch (error) {
                console.error('Error fetching artwork:', error);
            }
            
            return null;
        }
        
        // Display metadata with artwork
        async function displayMetadata(metadata) {
            let title = 'Unknown Track';
            let artist = 'Unknown Artist';
            let album = '';
            let streamArtworkUrl = null;
            
            // Parse metadata
            if (metadata) {
                // Check for ICY metadata
                if (metadata.StreamTitle) {
                    const parts = metadata.StreamTitle.split(' - ');
                    if (parts.length >= 2) {
                        artist = parts[0].trim();
                        title = parts.slice(1).join(' - ').trim();
                    } else {
                        title = metadata.StreamTitle.trim();
                    }
                }
            }
            
            // Check for stream-provided artwork
            if (metadata.StreamUrl) {
                streamArtworkUrl = metadata.StreamUrl;
            }
            
            // Check for OGG metadata
            if (metadata.ARTIST) artist = metadata.ARTIST;
            if (metadata.TITLE) title = metadata.TITLE;
            if (metadata.ALBUM) album = metadata.ALBUM;
            
            // Show loading state
            metadataDiv.innerHTML = `
                <div class="album-art-container">
                    <div class="loading-spinner">üîç Searching...</div>
                </div>
                <div class="metadata-text">
                    <div class="now-playing-label">NOW PLAYING</div>
                    <div class="song-title">${title}</div>
                    <div class="artist-name">${artist}</div>
                    ${album ? `<div class="album-name">${album}</div>` : ''}
                </div>
            `;
            
            // Get artwork (async)
            const artworkUrl = await getArtwork(artist, title, streamArtworkUrl);
            
            // Build final display
            let html = '';
            
            if (artworkUrl) {
                html += `
                    <div class="album-art-container">
                        <img src="${artworkUrl}" alt="Album Art" class="album-art" 
                             onerror="this.parentElement.innerHTML='<div class=\\'album-art-placeholder\\'>üéµ</div>'">
                    </div>
                `;
            } else {
                html += `
                    <div class="album-art-container">
                        <div class="album-art-placeholder">üéµ</div>
                    </div>
                `;
            }
            
            html += `
                <div class="metadata-text">
                    <div class="now-playing-label">NOW PLAYING</div>
                    <div class="song-title">${title}</div>
                    <div class="artist-name">${artist}</div>
                    ${album ? `<div class="album-name">${album}</div>` : ''}
                </div>
            `;
            
            metadataDiv.innerHTML = html;
        }
        
        // Get stream URL based on mode and quality
        function getStreamUrl() {
            if (isStationMode) {
                if (!currentStation) {
                    return null;
                }
                
                let url;
                // Return URL based on selected quality
                if (selectedQuality === 'low' && currentStation.url_resolved) {
                    url = currentStation.url_resolved;
                } else if (selectedQuality === 'high' && currentStation.hls) {
                    url = currentStation.hls;
                } else {
                    url = currentStation.url;
                }
                
                // Apply CORS proxy if enabled
                const useCorsProxy = document.getElementById('useCorsProxyStation').checked;
                if (useCorsProxy) {
                    url = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                }
                
                return url;
            } else {
                let url = streamUrlInput.value.trim();
                const useCorsProxy = document.getElementById('useCorsProxy').checked;
                
                if (useCorsProxy) {
                    url = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                }
                
                return url;
            }
        }
        
        // Play button handler
        playBtn.addEventListener('click', async () => {
            const streamUrl = getStreamUrl();
            
            if (!streamUrl) {
                updateStatus('Please select a station or enter a URL', 'error');
                return;
            }
            
            // Validate Last.fm API key if selected
            if (artworkApiSelect.value === 'lastfm' && !apiKeyInput.value.trim()) {
                updateStatus('Please enter your Last.fm API key', 'error');
                return;
            }
            
            // Stop existing player if running
            if (player) {
                player.stop();
            }
            
            // Update UI
            playBtn.disabled = true;
            stopBtn.disabled = false;
            updateStatus('Connecting...', 'loading');
            metadataDiv.innerHTML = `
                <div class="metadata-text centered">
                    <div class="now-playing-label">NOW PLAYING</div>
                    <div class="no-metadata">Loading stream...</div>
                </div>
            `;
            
            try {
                // Try to create player with full metadata support first
                let metadataTypes = ['icy', 'ogg'];
                let corsRetry = true;
                
                const createPlayer = (types) => {
                    return new IcecastMetadataPlayer(streamUrl, {
                        metadataTypes: types,
                        enableLogging: true,
                        
                        onMetadata: (metadata) => {
                            displayMetadata(metadata);
                        },
                        
                        onPlay: () => {
                            updateStatus('Playing', 'playing');
                        },
                        
                        onStop: () => {
                            updateStatus('Stopped', 'stopped');
                            playBtn.disabled = false;
                            stopBtn.disabled = true;
                            metadataDiv.innerHTML = `
                                <div class="metadata-text centered">
                                    <div class="now-playing-label">NOW PLAYING</div>
                                    <div class="no-metadata">Select a station to start streaming</div>
                                </div>
                            `;
                        },
                        
                        onError: async (error) => {
                            console.error('Player error:', error);
                            
                            // Check if this is a CORS error and we haven't retried yet
                            if (corsRetry && error.toString().includes('CORS')) {
                                corsRetry = false;
                                updateStatus('CORS issue detected, retrying without ICY metadata...', 'loading');
                                
                                // Stop current player
                                if (player) {
                                    player.stop();
                                }
                                
                                // Try with OGG only
                                try {
                                    player = createPlayer(['ogg']);
                                    await player.play();
                                } catch (retryError) {
                                    // If that fails too, try with no metadata
                                    try {
                                        updateStatus('Retrying without metadata...', 'loading');
                                        player = createPlayer([]);
                                        await player.play();
                                        updateStatus('Playing (no metadata available due to CORS)', 'playing');
                                    } catch (finalError) {
                                        updateStatus(`Error: Stream unavailable (CORS policy)`, 'error');
                                        playBtn.disabled = false;
                                        stopBtn.disabled = true;
                                    }
                                }
                            } else {
                                updateStatus(`Error: ${error}`, 'error');
                                playBtn.disabled = false;
                                stopBtn.disabled = true;
                            }
                        },
                        
                        bufferLength: 3,
                        retryTimeout: 10,
                        retryDelayRate: 0.5,
                        retryDelayMin: 1,
                        retryDelayMax: 30
                    });
                };
                
                player = createPlayer(metadataTypes);
                await player.play();
                
            } catch (error) {
                console.error('Failed to start player:', error);
                updateStatus(`Error: ${error.message}`, 'error');
                playBtn.disabled = false;
                stopBtn.disabled = true;
            }
        });
        
        // Stop button handler
        stopBtn.addEventListener('click', () => {
            if (player) {
                player.stop();
            }
        });
        
        // Allow Enter key to play (for custom URL mode)
        streamUrlInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !playBtn.disabled) {
                playBtn.click();
            }
        });
        
        // Allow Enter key in search
        stationSearch.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && filteredStations.length > 0) {
                selectStation(filteredStations[0].stationuuid);
            }
        });
        
        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && stationModal.classList.contains('active')) {
                stationModal.classList.remove('active');
            }
        });
        
        // Initialize: Load stations
        loadStations();
    </script>
</body>
</html>

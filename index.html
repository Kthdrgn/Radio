<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radio Stream Player with Station Database</title>
    
    <!-- Load the icecast-metadata-player library from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/icecast-metadata-player@1.17.13/build/icecast-metadata-player-1.17.13.main.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .player-container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
        }
        
        .player-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .player-header h1 {
            color: #333;
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .station-count {
            color: #667eea;
            font-size: 14px;
            font-weight: 500;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group label {
            display: block;
            color: #666;
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .quality-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .quality-btn {
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            text-align: center;
        }
        
        .quality-btn:hover:not(:disabled) {
            border-color: #667eea;
            background: #f0f7ff;
        }
        
        .quality-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }
        
        .quality-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .api-info {
            background: #f0f7ff;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            color: #555;
            margin-top: 5px;
        }
        
        .api-info a {
            color: #667eea;
            text-decoration: none;
        }
        
        .api-info a:hover {
            text-decoration: underline;
        }
        
        .metadata-display {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
            min-height: 120px;
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .album-art-container {
            flex-shrink: 0;
            position: relative;
        }
        
        .album-art {
            width: 150px;
            height: 150px;
            border-radius: 8px;
            object-fit: cover;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .album-art-placeholder {
            width: 150px;
            height: 150px;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
        }
        
        .loading-spinner {
            width: 150px;
            height: 150px;
            border-radius: 8px;
            background: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #999;
        }
        
        .metadata-text {
            flex: 1;
            text-align: left;
        }
        
        .metadata-text.centered {
            text-align: center;
        }
        
        .now-playing-label {
            color: #999;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }
        
        .song-title {
            color: #333;
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 8px;
            word-wrap: break-word;
        }
        
        .artist-name {
            color: #666;
            font-size: 18px;
            word-wrap: break-word;
        }
        
        .album-name {
            color: #999;
            font-size: 14px;
            margin-top: 4px;
            font-style: italic;
        }
        
        .no-metadata {
            color: #999;
            font-style: italic;
            padding: 20px 0;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
        }
        
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
        }
        
        .btn-play {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-play:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-play:active {
            transform: translateY(0);
        }
        
        .btn-stop {
            background: #ff4757;
            color: white;
        }
        
        .btn-stop:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 71, 87, 0.4);
        }
        
        .btn-stop:active {
            transform: translateY(0);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .status {
            text-align: center;
            margin-top: 20px;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .status.playing {
            background: #d4edda;
            color: #155724;
        }
        
        .status.stopped {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status.loading {
            background: #fff3cd;
            color: #856404;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
            cursor: pointer;
        }
        
        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            font-size: 13px;
        }
        
        .mode-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }
        
        .mode-btn:hover:not(.active) {
            border-color: #667eea;
            background: #f0f7ff;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="player-container">
        <div class="player-header">
            <h1>üéµ Radio Stream Player</h1>
            <div class="station-count">Loading stations...</div>
        </div>
        
        <!-- Mode Toggle -->
        <div class="mode-toggle">
            <button class="mode-btn active" id="stationModeBtn">Station Database</button>
            <button class="mode-btn" id="customModeBtn">Custom URL</button>
        </div>
        
        <!-- Station Selection Mode -->
        <div id="stationMode">
            <div class="input-group">
                <label for="stationSelect">Select a Radio Station</label>
                <select id="stationSelect">
                    <option value="">Choose a station...</option>
                </select>
            </div>
            
            <div class="input-group" id="qualityGroup" style="display: none;">
                <label>Stream Quality</label>
                <div class="quality-selector">
                    <button class="quality-btn" id="qualityLow" data-quality="low">
                        Low<br><span style="font-size: 11px; color: #999;">Bandwidth</span>
                    </button>
                    <button class="quality-btn active" id="qualityStandard" data-quality="standard">
                        Standard<br><span style="font-size: 11px; color: #999;">Recommended</span>
                    </button>
                    <button class="quality-btn" id="qualityHigh" data-quality="high">
                        High<br><span style="font-size: 11px; color: #999;">Quality</span>
                    </button>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="useCorsProxyStation">
                    <label for="useCorsProxyStation">Use CORS Proxy (if stream has CORS issues)</label>
                </div>
            </div>
        </div>
        
        <!-- Custom URL Mode -->
        <div id="customMode" class="hidden">
            <div class="input-group">
                <label for="streamUrl">Stream URL</label>
                <input type="text" id="streamUrl" placeholder="Enter radio stream URL (e.g., http://stream.example.com:8000/stream)">
                
                <div class="checkbox-group">
                    <input type="checkbox" id="useCorsProxy">
                    <label for="useCorsProxy">Use CORS Proxy (if stream has CORS issues)</label>
                </div>
            </div>
        </div>
        
        <!-- Artwork API Selection -->
        <div class="input-group">
            <label for="artworkApi">Artwork Source</label>
            <select id="artworkApi">
                <option value="stream">Stream Only (No API)</option>
                <option value="musicbrainz" selected>MusicBrainz (Free, No Key)</option>
                <option value="itunes">iTunes (Free, No Key)</option>
                <option value="lastfm">Last.fm (Requires API Key)</option>
            </select>
            <div class="api-info" id="apiInfo">
                <strong>MusicBrainz:</strong> Free, no API key required. Best coverage for official releases.
            </div>
        </div>
        
        <div class="input-group" id="apiKeyGroup" style="display: none;">
            <label for="apiKey">Last.fm API Key</label>
            <input type="text" id="apiKey" placeholder="Enter your Last.fm API key">
            <div class="api-info">
                Get a free API key at <a href="https://www.last.fm/api/account/create" target="_blank">Last.fm API</a>
            </div>
        </div>
        
        <!-- Metadata Display -->
        <div class="metadata-display" id="metadata">
            <div class="metadata-text centered">
                <div class="now-playing-label">NOW PLAYING</div>
                <div class="no-metadata">Select a station to start streaming</div>
            </div>
        </div>
        
        <!-- Playback Controls -->
        <div class="controls">
            <button class="btn btn-play" id="playBtn">‚ñ∂ Play</button>
            <button class="btn btn-stop" id="stopBtn" disabled>‚èπ Stop</button>
        </div>
        
        <!-- Status Display -->
        <div class="status" id="status">Ready to play</div>
    </div>
    
    <script>
        // Station database - will be populated from JSON
        let stations = [];
        let currentStation = null;
        let selectedQuality = 'standard';
        let isStationMode = true;
        
        // DOM Elements
        const stationSelect = document.getElementById('stationSelect');
        const streamUrlInput = document.getElementById('streamUrl');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const metadataDiv = document.getElementById('metadata');
        const statusDiv = document.getElementById('status');
        const artworkApiSelect = document.getElementById('artworkApi');
        const apiKeyInput = document.getElementById('apiKey');
        const apiKeyGroup = document.getElementById('apiKeyGroup');
        const qualityGroup = document.getElementById('qualityGroup');
        const qualityButtons = document.querySelectorAll('.quality-btn');
        
        // Mode switching
        const stationModeBtn = document.getElementById('stationModeBtn');
        const customModeBtn = document.getElementById('customModeBtn');
        const stationMode = document.getElementById('stationMode');
        const customMode = document.getElementById('customMode');
        
        // Player instance
        let player = null;
        
        // Artwork cache to avoid repeated API calls
        const artworkCache = new Map();
        
        // Load stations from JSON
        async function loadStations() {
            try {
                const response = await fetch('stations.json');
                stations = await response.json();
                
                // Populate dropdown
                stations.forEach(station => {
                    const option = document.createElement('option');
                    option.value = station.name;
                    option.textContent = station.name;
                    stationSelect.appendChild(option);
                });
                
                document.querySelector('.station-count').textContent = 
                    `${stations.length} stations available`;
                    
            } catch (error) {
                console.error('Failed to load stations:', error);
                document.querySelector('.station-count').textContent = 
                    'Error loading stations';
            }
        }
        
        // Mode switching handlers
        stationModeBtn.addEventListener('click', () => {
            isStationMode = true;
            stationModeBtn.classList.add('active');
            customModeBtn.classList.remove('active');
            stationMode.classList.remove('hidden');
            customMode.classList.add('hidden');
        });
        
        customModeBtn.addEventListener('click', () => {
            isStationMode = false;
            customModeBtn.classList.add('active');
            stationModeBtn.classList.remove('active');
            customMode.classList.remove('hidden');
            stationMode.classList.add('hidden');
            qualityGroup.style.display = 'none';
        });
        
        // Station selection handler
        stationSelect.addEventListener('change', (e) => {
            const stationName = e.target.value;
            if (!stationName) {
                currentStation = null;
                qualityGroup.style.display = 'none';
                return;
            }
            
            currentStation = stations.find(s => s.name === stationName);
            
            // Show quality selector and configure buttons
            qualityGroup.style.display = 'block';
            
            // Enable/disable quality buttons based on available URLs
            document.getElementById('qualityLow').disabled = !currentStation.url_low;
            document.getElementById('qualityHigh').disabled = !currentStation.url_high;
            
            // Reset to standard quality
            selectedQuality = 'standard';
            qualityButtons.forEach(btn => btn.classList.remove('active'));
            document.getElementById('qualityStandard').classList.add('active');
        });
        
        // Quality selection handlers
        qualityButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                if (!btn.disabled) {
                    selectedQuality = btn.dataset.quality;
                    qualityButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                }
            });
        });
        
        // Show/hide API key input based on selection
        artworkApiSelect.addEventListener('change', () => {
            const apiInfo = document.getElementById('apiInfo');
            
            if (artworkApiSelect.value === 'lastfm') {
                apiKeyGroup.style.display = 'block';
                apiInfo.innerHTML = 'Get a free API key at <a href="https://www.last.fm/api/account/create" target="_blank">Last.fm API</a>';
            } else if (artworkApiSelect.value === 'musicbrainz') {
                apiKeyGroup.style.display = 'none';
                apiInfo.innerHTML = '<strong>MusicBrainz:</strong> Free, no API key required. Best coverage for official releases.';
            } else if (artworkApiSelect.value === 'itunes') {
                apiKeyGroup.style.display = 'none';
                apiInfo.innerHTML = '<strong>iTunes:</strong> Free, no API key required. Good for popular music.';
            } else {
                apiKeyGroup.style.display = 'none';
                apiInfo.innerHTML = '<strong>Stream Only:</strong> Uses artwork provided by the stream, if available.';
            }
        });
        
        // Update status display
        function updateStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + type;
        }
        
        // Get artwork from iTunes API
        async function getItunesArtwork(artist, title) {
            const cacheKey = `itunes-${artist}-${title}`;
            
            // Check cache first
            if (artworkCache.has(cacheKey)) {
                return artworkCache.get(cacheKey);
            }
            
            try {
                const searchTerm = `${artist} ${title}`.trim();
                const response = await fetch(
                    `https://itunes.apple.com/search?term=${encodeURIComponent(searchTerm)}&media=music&entity=song&limit=1`
                );
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    // Get high-res artwork (600x600)
                    const artworkUrl = data.results[0].artworkUrl100.replace('100x100', '600x600');
                    artworkCache.set(cacheKey, artworkUrl);
                    return artworkUrl;
                }
                
                artworkCache.set(cacheKey, null);
                return null;
            } catch (error) {
                console.error('iTunes API error:', error);
                return null;
            }
        }
        
        // Get artwork from MusicBrainz/Cover Art Archive
        async function getMusicBrainzArtwork(artist, title) {
            const cacheKey = `musicbrainz-${artist}-${title}`;
            
            // Check cache first
            if (artworkCache.has(cacheKey)) {
                return artworkCache.get(cacheKey);
            }
            
            try {
                // Step 1: Search for the recording
                const searchUrl = `https://musicbrainz.org/ws/2/recording/?query=artist:"${encodeURIComponent(artist)}" AND recording:"${encodeURIComponent(title)}"&fmt=json&limit=1`;
                
                const searchResponse = await fetch(searchUrl);
                const searchData = await searchResponse.json();
                
                if (!searchData.recordings || searchData.recordings.length === 0) {
                    artworkCache.set(cacheKey, null);
                    return null;
                }
                
                const recording = searchData.recordings[0];
                
                // Step 2: Get release information
                if (!recording.releases || recording.releases.length === 0) {
                    artworkCache.set(cacheKey, null);
                    return null;
                }
                
                const release = recording.releases[0];
                const releaseId = release.id;
                
                // Step 3: Try to get cover art from Cover Art Archive
                const artworkUrl = `https://coverartarchive.org/release/${releaseId}/front-250`;
                
                // Test if the artwork exists
                const artworkTest = await fetch(artworkUrl, { method: 'HEAD' });
                if (artworkTest.ok) {
                    artworkCache.set(cacheKey, artworkUrl);
                    return artworkUrl;
                }
                
                artworkCache.set(cacheKey, null);
                return null;
                
            } catch (error) {
                console.error('MusicBrainz lookup error:', error);
                return null;
            }
        }
        
        // Get artwork from Last.fm API
        async function getLastFmArtwork(artist, title, apiKey) {
            const cacheKey = `lastfm-${artist}-${title}`;
            
            // Check cache first
            if (artworkCache.has(cacheKey)) {
                return artworkCache.get(cacheKey);
            }
            
            try {
                const response = await fetch(
                    `https://ws.audioscrobbler.com/2.0/?method=track.getInfo&api_key=${apiKey}&artist=${encodeURIComponent(artist)}&track=${encodeURIComponent(title)}&format=json`
                );
                const data = await response.json();
                
                if (data.track && data.track.album && data.track.album.image) {
                    const images = data.track.album.image;
                    // Get the largest image (usually last in array)
                    const largeImage = images.find(img => img.size === 'extralarge') || images[images.length - 1];
                    if (largeImage && largeImage['#text']) {
                        const artworkUrl = largeImage['#text'];
                        artworkCache.set(cacheKey, artworkUrl);
                        return artworkUrl;
                    }
                }
                
                artworkCache.set(cacheKey, null);
                return null;
            } catch (error) {
                console.error('Last.fm API error:', error);
                return null;
            }
        }
        
        // Get artwork based on selected API
        async function getArtwork(artist, title, streamArtworkUrl) {
            // First, use stream-provided artwork if available
            if (streamArtworkUrl) {
                return streamArtworkUrl;
            }
            
            // Otherwise, use the selected API
            const apiChoice = artworkApiSelect.value;
            
            // If stream only mode, don't search APIs
            if (apiChoice === 'stream') {
                return null;
            }
            
            // Try MusicBrainz
            if (apiChoice === 'musicbrainz') {
                return await getMusicBrainzArtwork(artist, title);
            }
            
            // Try iTunes
            if (apiChoice === 'itunes') {
                return await getItunesArtwork(artist, title);
            }
            
            // Try Last.fm
            if (apiChoice === 'lastfm') {
                const apiKey = apiKeyInput.value.trim();
                if (!apiKey) {
                    console.warn('Last.fm API key not provided');
                    return null;
                }
                return await getLastFmArtwork(artist, title, apiKey);
            }
            
            return null;
        }
        
        // Parse iHeart-style metadata with XML-like attributes
        function parseIHeartMetadata(streamTitle) {
            const result = {
                artist: null,
                title: null,
                artwork: null
            };
            
            // Extract text attribute (song title)
            const textMatch = streamTitle.match(/text="([^"]+)"/);
            if (textMatch) {
                result.title = textMatch[1];
            }
            
            // Extract artwork URL
            const artworkMatch = streamTitle.match(/amgArtworkURL="([^"]+)"/);
            if (artworkMatch) {
                result.artwork = artworkMatch[1];
            }
            
            return result;
        }
        
        // Format and display metadata
        async function displayMetadata(metadata) {
            console.log('Metadata received:', metadata);
            
            // Clear the display
            metadataDiv.innerHTML = '';
            
            if (!metadata) {
                metadataDiv.innerHTML = `
                    <div class="metadata-text centered">
                        <div class="now-playing-label">NOW PLAYING</div>
                        <div class="no-metadata">No metadata available</div>
                    </div>
                `;
                return;
            }
            
            // Parse metadata
            let artist = 'Unknown Artist';
            let title = 'Unknown Title';
            let album = '';
            let streamArtworkUrl = null;
            
            if (metadata.StreamTitle) {
                // Check if this is iHeart-style metadata (contains attributes)
                if (metadata.StreamTitle.includes('text=') && metadata.StreamTitle.includes('"')) {
                    const iheartData = parseIHeartMetadata(metadata.StreamTitle);
                    
                    if (iheartData.title) {
                        // Parse artist - title from the text field
                        const parts = iheartData.title.split(' - ');
                        if (parts.length >= 2) {
                            artist = parts[0].trim();
                            title = parts.slice(1).join(' - ').trim();
                        } else {
                            title = iheartData.title.trim();
                        }
                    }
                    
                    // Use iHeart's artwork URL if available
                    if (iheartData.artwork) {
                        streamArtworkUrl = iheartData.artwork;
                    }
                } else {
                    // Standard metadata parsing
                    const parts = metadata.StreamTitle.split(' - ');
                    if (parts.length >= 2) {
                        artist = parts[0].trim();
                        title = parts.slice(1).join(' - ').trim();
                    } else {
                        title = metadata.StreamTitle.trim();
                    }
                }
            }
            
            // Check for stream-provided artwork
            if (metadata.StreamUrl) {
                streamArtworkUrl = metadata.StreamUrl;
            }
            
            // Check for OGG metadata
            if (metadata.ARTIST) artist = metadata.ARTIST;
            if (metadata.TITLE) title = metadata.TITLE;
            if (metadata.ALBUM) album = metadata.ALBUM;
            
            // Show loading state
            metadataDiv.innerHTML = `
                <div class="album-art-container">
                    <div class="loading-spinner">üîç Searching...</div>
                </div>
                <div class="metadata-text">
                    <div class="now-playing-label">NOW PLAYING</div>
                    <div class="song-title">${title}</div>
                    <div class="artist-name">${artist}</div>
                    ${album ? `<div class="album-name">${album}</div>` : ''}
                </div>
            `;
            
            // Get artwork (async)
            const artworkUrl = await getArtwork(artist, title, streamArtworkUrl);
            
            // Build final display
            let html = '';
            
            if (artworkUrl) {
                html += `
                    <div class="album-art-container">
                        <img src="${artworkUrl}" alt="Album Art" class="album-art" 
                             onerror="this.parentElement.innerHTML='<div class=\\'album-art-placeholder\\'>üéµ</div>'">
                    </div>
                `;
            } else {
                html += `
                    <div class="album-art-container">
                        <div class="album-art-placeholder">üéµ</div>
                    </div>
                `;
            }
            
            html += `
                <div class="metadata-text">
                    <div class="now-playing-label">NOW PLAYING</div>
                    <div class="song-title">${title}</div>
                    <div class="artist-name">${artist}</div>
                    ${album ? `<div class="album-name">${album}</div>` : ''}
                </div>
            `;
            
            metadataDiv.innerHTML = html;
        }
        
        // Get stream URL based on mode and quality
        function getStreamUrl() {
            if (isStationMode) {
                if (!currentStation) {
                    return null;
                }
                
                let url;
                // Return URL based on selected quality
                if (selectedQuality === 'low' && currentStation.url_low) {
                    url = currentStation.url_low;
                } else if (selectedQuality === 'high' && currentStation.url_high) {
                    url = currentStation.url_high;
                } else {
                    url = currentStation.url;
                }
                
                // Apply CORS proxy if enabled
                const useCorsProxy = document.getElementById('useCorsProxyStation').checked;
                if (useCorsProxy) {
                    url = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                }
                
                return url;
            } else {
                let url = streamUrlInput.value.trim();
                const useCorsProxy = document.getElementById('useCorsProxy').checked;
                
                if (useCorsProxy) {
                    url = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                }
                
                return url;
            }
        }
        
        // Play button handler
        playBtn.addEventListener('click', async () => {
            const streamUrl = getStreamUrl();
            
            if (!streamUrl) {
                updateStatus('Please select a station or enter a URL', 'error');
                return;
            }
            
            // Validate Last.fm API key if selected
            if (artworkApiSelect.value === 'lastfm' && !apiKeyInput.value.trim()) {
                updateStatus('Please enter your Last.fm API key', 'error');
                return;
            }
            
            // Stop existing player if running
            if (player) {
                player.stop();
            }
            
            // Update UI
            playBtn.disabled = true;
            stopBtn.disabled = false;
            updateStatus('Connecting...', 'loading');
            metadataDiv.innerHTML = `
                <div class="metadata-text centered">
                    <div class="now-playing-label">NOW PLAYING</div>
                    <div class="no-metadata">Loading stream...</div>
                </div>
            `;
            
            try {
                // Try to create player with full metadata support first
                let metadataTypes = ['icy', 'ogg'];
                let corsRetry = true;
                
                const createPlayer = (types) => {
                    return new IcecastMetadataPlayer(streamUrl, {
                        metadataTypes: types,
                        enableLogging: true,
                        
                        onMetadata: (metadata) => {
                            displayMetadata(metadata);
                        },
                        
                        onPlay: () => {
                            updateStatus('Playing', 'playing');
                        },
                        
                        onStop: () => {
                            updateStatus('Stopped', 'stopped');
                            playBtn.disabled = false;
                            stopBtn.disabled = true;
                            metadataDiv.innerHTML = `
                                <div class="metadata-text centered">
                                    <div class="now-playing-label">NOW PLAYING</div>
                                    <div class="no-metadata">Select a station to start streaming</div>
                                </div>
                            `;
                        },
                        
                        onError: async (error) => {
                            console.error('Player error:', error);
                            
                            // Check if this is a CORS error and we haven't retried yet
                            if (corsRetry && error.toString().includes('CORS')) {
                                corsRetry = false;
                                updateStatus('CORS issue detected, retrying without ICY metadata...', 'loading');
                                
                                // Stop current player
                                if (player) {
                                    player.stop();
                                }
                                
                                // Try with OGG only
                                try {
                                    player = createPlayer(['ogg']);
                                    await player.play();
                                } catch (retryError) {
                                    // If that fails too, try with no metadata
                                    try {
                                        updateStatus('Retrying without metadata...', 'loading');
                                        player = createPlayer([]);
                                        await player.play();
                                        updateStatus('Playing (no metadata available due to CORS)', 'playing');
                                    } catch (finalError) {
                                        updateStatus(`Error: Stream unavailable (CORS policy)`, 'error');
                                        playBtn.disabled = false;
                                        stopBtn.disabled = true;
                                    }
                                }
                            } else {
                                updateStatus(`Error: ${error}`, 'error');
                                playBtn.disabled = false;
                                stopBtn.disabled = true;
                            }
                        },
                        
                        bufferLength: 3,
                        retryTimeout: 10,
                        retryDelayRate: 0.5,
                        retryDelayMin: 1,
                        retryDelayMax: 30
                    });
                };
                
                player = createPlayer(metadataTypes);
                await player.play();
                
            } catch (error) {
                console.error('Failed to start player:', error);
                updateStatus(`Error: ${error.message}`, 'error');
                playBtn.disabled = false;
                stopBtn.disabled = true;
            }
        });
        
        // Stop button handler
        stopBtn.addEventListener('click', () => {
            if (player) {
                player.stop();
            }
        });
        
        // Allow Enter key to play (for custom URL mode)
        streamUrlInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !playBtn.disabled) {
                playBtn.click();
            }
        });
        
        // Initialize: Load stations
        loadStations();
    </script>
</body>
</html>
